package Ch02;
// data
//	: 선저장 - 숫자(정수(양수, 음수), 실수), 문자(단일문자(''), 문자열(""))
//	: 후처리

/*
	### 컴퓨터(CPU)는 구조상 덧셈연산를 할 수 있다 (O) ###
	### 컴퓨터(CPU)는 구조상 뺄셈연산를 할 수 있다 (X) ###
	
	컴퓨터(CPU)에서 뺄셈 요청 시 뺄셈 처리는 할 수 있다.
	--> 보수 개념을 도입해서 뺄셈 처리를 수행하기 때문에 가능
	
	7 - 4 = 3
	보수란? 보충해주는 수
	4에 대한 10의 보수 : 6
	7 + 6 = 13 -> 증가하는 자리수를 버림 == 3
	동일한 값 도출
	
	77 - 32 = 45
	77 + (100에대한 32의 보수==68) = 145 > 증가한 자리수를 버림 == 45
	
	기계 : 2진 데이터만 취급 ==> 그럼? 2에대한 보수를 구하면 됨
	
	5 - 5 구하기	
	0000 0101 = 5
  +	0000 0000 = -5 (5에 대한 2의 보수 == 11111011)
  ----------------
    0000 0000 = 0
	
	계산이 편하게 1의 보수를 구해 끝자리에 1을 더함
	0000 0101 = 5
	1111 1010 = -6 (5에 대한 1의 보수 == 전부를 1111 1111로 만드는 값)
  + 0000 0001 =	
  +	1111 1011 = -5 (5에 대한 2의 보수 == 전부를 1 0000 0000으로 만드는 값)
  ----------------
    0000 0000 = 0
    
    제일 왼편의 수 : 부호 비트 < 공간이 음수를 지원할 때 한정
    11111011의 맨 처음 1
 */

// 문제 풀기 ----------------------------------------------------------------
// 음수값임을 고려하여 풉니다
// 10 진수 	-> 2진수
// 111 		-> 01101111
// -111 	-> 10010001
// 96		-> 01100000
// -96		-> 10100000
// 31 		-> 00011111
// -31		-> 11100001

// 2진수		-> 10진수
// 10101111	-> 1+2+4+8+32-128 = -81
// 00110101	-> 1+4+16+32 = 53
// 11001100	-> 4+8+64-128 = -52
// 10101010	-> 2+8+32-128 = -86



public class C02음수 {
	public static void main(String[] args) {
		char a = (char)-10; // 양수만 지원
		short b = (short)-10; // 음수도 지원
		System.out.println(a); // 음수값이 이상하게 나오는 걸 볼 수 있음 == 음수 지원을 안해서
		System.out.println(b);
	}
}
